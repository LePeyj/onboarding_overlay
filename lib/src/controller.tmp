import 'package:flutter/foundation.dart';

/// The status of an onboarding.
enum OnboardingStatus {
  /// The onboarding is stopped at the beginning.
  idle,

  /// The onboarding is stopped at the end.
  completed,
}

/// Signature for listeners attached using [OnBoardingController.addStatusListener].
typedef OnboardingStatusListener = void Function(OnboardingStatus status);

abstract class OnboardingProgress<T> extends Listenable
    implements ValueListenable<T> {
  /// Abstract const constructor. This constructor enables subclasses to provide
  /// const constructors so that they can be used in const expressions.
  const OnboardingProgress();

  // keep these next five dartdocs in sync with the dartdocs in onboardingWithParentMixin<T>

  /// Calls the listener every time the value of the onboarding changes.
  ///
  /// Listeners can be removed with [removeListener].
  @override
  void addListener(VoidCallback listener);

  /// Stop calling the listener every time the value of the onboarding changes.
  ///
  /// If `listener` is not currently registered as a listener, this method does
  /// nothing.
  ///
  /// Listeners can be added with [addListener].
  @override
  void removeListener(VoidCallback listener);

  /// Calls listener every time the status of the onboarding changes.
  ///
  /// Listeners can be removed with [removeStatusListener].
  void addStatusListener(OnboardingStatusListener listener);

  /// Stops calling the listener every time the status of the onboarding changes.
  ///
  /// If `listener` is not currently registered as a status listener, this
  /// method does nothing.
  ///
  /// Listeners can be added with [addStatusListener].
  void removeStatusListener(OnboardingStatusListener listener);

  /// The current status of this onboarding.
  OnboardingStatus get status;

  /// The current value of the onboarding.
  @override
  T get value;

  /// Whether this onboarding is stopped at the beginning.
  bool get isDismissed => status == OnboardingStatus.idle;

  /// Whether this onboarding is stopped at the end.
  bool get isCompleted => status == OnboardingStatus.completed;

  @override
  String toString() {
    return '${describeIdentity(this)}(${toStringDetails()})';
  }

  String toStringDetails() {
    assert(status != null);
    switch (status) {
      case OnboardingStatus.completed:
        return '>|';
      case OnboardingStatus.idle:
        return '|>';
    }
  }
}

/// A mixin that helps listen to another object only when this object has registered listeners.
///
/// This mixin provides implementations of [didRegisterListener] and [didUnregisterListener],
/// and therefore can be used in conjunction with mixins that require these methods,
/// [onboardingLocalListenersMixin] and [onboardingLocalStatusListenersMixin].
mixin OnboardingLazyListenerMixin {
  int _listenerCounter = 0;

  /// Calls [didStartListening] every time a registration of a listener causes
  /// an empty list of listeners to become non-empty.
  ///
  /// See also:
  ///
  ///  * [didUnregisterListener], which may cause the listener list to
  ///    become empty again, and in turn cause this method to call
  ///    [didStartListening] again.
  void didRegisterListener() {
    assert(_listenerCounter >= 0);
    if (_listenerCounter == 0) didStartListening();
    _listenerCounter += 1;
  }

  /// Calls [didStopListening] when an only remaining listener is unregistered,
  /// thus making the list empty.
  ///
  /// See also:
  ///
  ///  * [didRegisterListener], which causes the listener list to become non-empty.
  void didUnregisterListener() {
    assert(_listenerCounter >= 1);
    _listenerCounter -= 1;
    if (_listenerCounter == 0) didStopListening();
  }

  /// Called when the number of listeners changes from zero to one.
  @protected
  void didStartListening();

  /// Called when the number of listeners changes from one to zero.
  @protected
  void didStopListening();

  /// Whether there are any listeners.
  bool get isListening => _listenerCounter > 0;
}

/// A mixin that replaces the [didRegisterListener]/[didUnregisterListener] contract
/// with a dispose contract.
///
/// This mixin provides implementations of [didRegisterListener] and [didUnregisterListener],
/// and therefore can be used in conjunction with mixins that require these methods,
/// [onboardingLocalListenersMixin] and [onboardingLocalStatusListenersMixin].
mixin OnboardingEagerListenerMixin {
  /// This implementation ignores listener registrations.
  void didRegisterListener() {}

  /// This implementation ignores listener registrations.
  void didUnregisterListener() {}

  /// Release the resources used by this object. The object is no longer usable
  /// after this method is called.
  @mustCallSuper
  void dispose() {}
}

/// A mixin that implements the [addListener]/[removeListener] protocol and notifies
/// all the registered listeners when [notifyListeners] is called.
///
/// This mixin requires that the mixing class provide methods [didRegisterListener]
/// and [didUnregisterListener]. Implementations of these methods can be obtained
/// by mixing in another mixin from this library, such as [onboardingLazyListenerMixin].
mixin OnboardingLocalListenersMixin {
  final ObserverList<VoidCallback> _listeners = ObserverList<VoidCallback>();

  /// Called immediately before a listener is added via [addListener].
  ///
  /// At the time this method is called the registered listener is not yet
  /// notified by [notifyListeners].
  void didRegisterListener();

  /// Called immediately after a listener is removed via [removeListener].
  ///
  /// At the time this method is called the removed listener is no longer
  /// notified by [notifyListeners].
  void didUnregisterListener();

  /// Calls the listener every time the value of the onboarding changes.
  ///
  /// Listeners can be removed with [removeListener].
  void addListener(VoidCallback listener) {
    didRegisterListener();
    _listeners.add(listener);
  }

  /// Stop calling the listener every time the value of the onboarding changes.
  ///
  /// Listeners can be added with [addListener].
  void removeListener(VoidCallback listener) {
    final bool removed = _listeners.remove(listener);
    if (removed) {
      didUnregisterListener();
    }
  }

  /// Calls all the listeners.
  ///
  /// If listeners are added or removed during this function, the modifications
  /// will not change which listeners are called during this iteration.
  void notifyListeners() {
    final List<VoidCallback> localListeners =
        List<VoidCallback>.from(_listeners);
    for (final VoidCallback listener in localListeners) {
      InformationCollector? collector;
      assert(() {
        collector = () sync* {
          yield DiagnosticsProperty<OnboardingLocalListenersMixin>(
            'The $runtimeType notifying listeners was',
            this,
            style: DiagnosticsTreeStyle.errorProperty,
          );
        };
        return true;
      }());
      try {
        if (_listeners.contains(listener)) listener();
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'onboarding library',
          context:
              ErrorDescription('while notifying listeners for $runtimeType'),
          informationCollector: collector,
        ));
      }
    }
  }
}

/// A mixin that implements the addStatusListener/removeStatusListener protocol
/// and notifies all the registered listeners when notifyStatusListeners is
/// called.
///
/// This mixin requires that the mixing class provide methods [didRegisterListener]
/// and [didUnregisterListener]. Implementations of these methods can be obtained
/// by mixing in another mixin from this library, such as [onboardingLazyListenerMixin].
mixin OnboardingLocalStatusListenersMixin {
  final ObserverList<OnboardingStatusListener> _statusListeners =
      ObserverList<OnboardingStatusListener>();

  /// Called immediately before a status listener is added via [addStatusListener].
  ///
  /// At the time this method is called the registered listener is not yet
  /// notified by [notifyStatusListeners].
  void didRegisterListener();

  /// Called immediately after a status listener is removed via [removeStatusListener].
  ///
  /// At the time this method is called the removed listener is no longer
  /// notified by [notifyStatusListeners].
  void didUnregisterListener();

  /// Calls listener every time the status of the onboarding changes.
  ///
  /// Listeners can be removed with [removeStatusListener].
  void addStatusListener(OnboardingStatusListener listener) {
    didRegisterListener();
    _statusListeners.add(listener);
  }

  /// Stops calling the listener every time the status of the onboarding changes.
  ///
  /// Listeners can be added with [addStatusListener].
  void removeStatusListener(OnboardingStatusListener listener) {
    final bool removed = _statusListeners.remove(listener);
    if (removed) {
      didUnregisterListener();
    }
  }

  /// Calls all the status listeners.
  ///
  /// If listeners are added or removed during this function, the modifications
  /// will not change which listeners are called during this iteration.
  void notifyStatusListeners(OnboardingStatus status) {
    final List<OnboardingStatusListener> localListeners =
        List<OnboardingStatusListener>.from(_statusListeners);
    for (final OnboardingStatusListener listener in localListeners) {
      try {
        if (_statusListeners.contains(listener)) listener(status);
      } catch (exception, stack) {
        InformationCollector? collector;
        assert(() {
          collector = () sync* {
            yield DiagnosticsProperty<OnboardingLocalStatusListenersMixin>(
              'The $runtimeType notifying status listeners was',
              this,
              style: DiagnosticsTreeStyle.errorProperty,
            );
          };
          return true;
        }());
        FlutterError.reportError(FlutterErrorDetails(
            exception: exception,
            stack: stack,
            library: 'onboarding library',
            context: ErrorDescription(
                'while notifying status listeners for $runtimeType'),
            informationCollector: collector));
      }
    }
  }
}

abstract class OnboardingController extends OnboardingProgress<int>
    with
        OnboardingEagerListenerMixin,
        OnboardingLocalListenersMixin,
        OnboardingLocalStatusListenersMixin {
  OnboardingController({
    int? value,
    this.stepIndexes = const <int>[],
  }) {
    _internalSetValue(value ?? 0);
  }

  final List<int> stepIndexes;

  @override
  int get value => _value;
  late int _value;

  set value(int newValue) {
    stop();
    // _internalSetValue(newValue);
    notifyListeners();
    _checkStatusChanged();
  }

  /// The current status of this onboarding.
  @override
  OnboardingStatus get status => _status;
  late OnboardingStatus _status;

  OnboardingStatus _lastReportedStatus = OnboardingStatus.idle;
  void _checkStatusChanged() {
    final OnboardingStatus newStatus = status;
    if (_lastReportedStatus != newStatus) {
      _lastReportedStatus = newStatus;
      notifyStatusListeners(newStatus);
    }
  }

  void stop() {
    _status = OnboardingStatus.stopped;
    _checkStatusChanged();
  }

  void _internalSetValue(int newValue) {
    if (stepIndexes.isNotEmpty) {
      _value = newValue.clamp(stepIndexes.first, stepIndexes.last);
      if (_value == stepIndexes.last) {
        _status = OnboardingStatus.completed;
      } else {
        _status = OnboardingStatus.idle;
      }
    } else {
      _value = newValue;
      _status = OnboardingStatus.idle;
    }
  }
}
